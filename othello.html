<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="author" content="Rocky">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Othello</title>
</head>

<body>
  <div id="container"></div>
  <script>
    // 用数据结构表示棋盘信息
    let board = [
      [0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 1, 2, 0, 0, 0],
      [0, 0, 0, 2, 1, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0],
    ];
    let curColorValue = 1;
    // 棋盘容器
    const container = document.getElementById("container");
    render();

    function render() {
      // 清空旧的
      container.innerHTML = '';

      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          // 棋盘格
          const grid = document.createElement("div");
          grid.style = "display: inline-block; width: 50px; height: 50px; background-color: darkcyan; border: solid white 1px; vertical-align: bottom;";

          // 绑定点击
          grid.addEventListener("click", () => {
            if (board[y][x]) return;

            const curColor = (curColorValue === 1) ? 'black' : 'antiquewhite';
            const disc = document.createElement("div");
            disc.style = `margin: 5px; width: 40px; height: 40px; border-radius: 20px; background-color: ${curColor};`
            grid.appendChild(disc);
            console.log(x, y, curColor);

            let originalX = x, originalY = y;
            // 类似的逻辑在 8 个方向上，为了不重复 8 次，用把逻辑抽象出来
            // 处理几何相关问题时常用向量思想
            const directions = [
              [0, -1],
              [0, 1],
              [-1, 0],
              [1, 0],
              [-1, -1],
              [1, -1],
              [1, 1],
              [-1, 1]
            ];

            let canCapture = false;
            // 八个方向 while true +  break
            for (const direction of directions) {
              x = originalX; // 每个方向的判断开始时都需要重置 x y 值
              y = originalY;
              let directionCanCapture = false;
              let directionHasOpposite = false;
              // 开始每个方向的判断
              while (true) {
                x += direction[0];
                y += direction[1];
                // 出界
                if (x < 0 || x > 7 || y < 0 || y > 7) {
                  break;
                }
                // 找能吃的子
                if (board[y][x] === 3 - curColorValue) {
                  directionHasOpposite = true;
                }
                if (board[y][x] === curColorValue) {
                  if (directionHasOpposite) {
                    directionCanCapture = true;
                  }
                  break;
                }
                if (board[y][x] === 0) {
                  break;
                }
              }
              // 上一个 while 可能找出了该方向上能吃的点
              if (directionCanCapture) {
                while (true) { // 类似的，如果能吃，现在在远端同色点，必须先退一步到异色点，才能吃子改色。先变 x 再用其值，所以while true => x+=n => 判断 x => 用x值操作
                  x -= direction[0];
                  y -= direction[1];
                  if (x === originalX && y === originalY) {
                    break;
                  }
                  board[y][x] = curColorValue;
                }
                // 点击位置的落子不能放在循环中的单方向操作中了，否则会重复操作。拎出来，如果任一方向能吃子，单独进行落子操作。
                canCapture = canCapture || directionCanCapture;
              }
            }
            if (canCapture) {
              board[originalY][originalX] = curColorValue;
              curColorValue = 3 - curColorValue; // switch bewteen 1 and 2 
            }
            render();
          });

          container.appendChild(grid);
          // 棋子 css 伪元素？
          if (board[y][x] === 1) {
            const disc = document.createElement("div");
            disc.style = "margin: 5px; width: 40px; height: 40px; border-radius: 20px; background-color: black;"
            grid.appendChild(disc)
          }
          if (board[y][x] === 2) {
            const disc = document.createElement("div");
            disc.style = "margin: 5px; width: 40px; height: 40px; border-radius: 20px; background-color: antiquewhite;"
            grid.appendChild(disc)
          }
        };
        // 分行
        container.appendChild(document.createElement("br"));
      };
    }


  </script>
</body>

</html>