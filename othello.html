<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="author" content="Rocky">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Othello</title>
</head>

<body>
  <div id="container"></div>
  <script>
    // 用数据结构表示棋盘信息
    // let board = [
    //   [0, 0, 0, 0, 0, 0, 0, 0],
    //   [0, 0, 0, 0, 0, 0, 0, 0],
    //   [0, 0, 0, 0, 0, 0, 0, 0],
    //   [0, 0, 0, 1, 2, 0, 0, 0],
    //   [0, 0, 0, 2, 1, 0, 0, 0],
    //   [0, 0, 0, 0, 0, 0, 0, 0],
    //   [0, 0, 0, 0, 0, 0, 0, 0],
    //   [0, 0, 0, 0, 0, 0, 0, 0],
    // ];
    let board = [
      [0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 1, 2, 0],
      [0, 0, 0, 0, 0, 0, 2, 2],
      [0, 0, 0, 0, 0, 2, 2, 2],
    ];
    let curColorValue = 1;
    // 棋盘容器
    const container = document.getElementById("container");
    render();

    function move(x, y, checkOnly = false) {
      if (board[y][x]) return false;

      let originalX = x, originalY = y;
      // 类似的逻辑在 8 个方向上，为了不重复 8 次，用把逻辑抽象出来
      // 处理几何相关问题时常用向量思想
      const directions = [
        [0, -1],
        [0, 1],
        [-1, 0],
        [1, 0],
        [-1, -1],
        [1, -1],
        [1, 1],
        [-1, 1]
      ];

      let canCapture = false;
      // 八个方向 while true +  break
      for (const direction of directions) {
        x = originalX; // 每个方向的判断开始时都需要重置 x y 值
        y = originalY;
        let directionCanCapture = false;
        let directionHasOpposite = false;
        // 开始每个方向的判断
        while (true) {
          x += direction[0];
          y += direction[1];
          // 出界
          if (x < 0 || x > 7 || y < 0 || y > 7) {
            break;
          }
          // 找能吃的子
          if (board[y][x] === 3 - curColorValue) {
            directionHasOpposite = true;
          }
          if (board[y][x] === curColorValue) {
            if (directionHasOpposite) {
              directionCanCapture = true;
            }
            break;
          }
          if (board[y][x] === 0) {
            break;
          }
        }
        // 上一个 while 可能找出了该方向上能吃的点
        if (directionCanCapture && !checkOnly) {
          while (true) { // 类似的，如果能吃，现在在远端同色点，必须先退一步到异色点，才能吃子改色。先变 x 再用其值，所以while true => x+=n => 判断 x => 用x值操作
            x -= direction[0];
            y -= direction[1];
            if (x === originalX && y === originalY) {
              break;
            }
            board[y][x] = curColorValue;
          }
        }
        // canCapture 的更新发生在每次方向判断里，无论是否是 checkOnly 模式
        canCapture = canCapture || directionCanCapture;
      }
      if (canCapture && !checkOnly) {
        board[originalY][originalX] = curColorValue;
        curColorValue = 3 - curColorValue; // switch bewteen 1 and 2 
      }
      // 8 个方向中是否有可以吃对方子的地方，若有，当前点位可以落子
      return canCapture
    }

    function checkPass() {
      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          // 检测棋盘每个位置，是否有任一位置可以落子
          if (move(x, y, true)) {
            return false;
          }
        };
      };
      return true;
    }

    function judge() {
      // // 得到一个包含所有非0结果的数组
      // board.reduce((acc, line) => (
      //   [...acc, ...(line.filter(grid => grid !== 0))]
      // ), [])
      // // 得到两个分别是 1 与 2 的数组
      // board.reduce(([black, white], line) => {
      //   const [curBlack, curWhite] = line.reduce(([b, w], grid) => {
      //     if (grid === 1) b = [...b, grid];
      //     if (grid === 2) w = [...w, grid];
      //     return [b, w]
      //   }, [[], []])
      //   return [[...black, ...curBlack], [...white, ...curWhite]];
      // }, [[], []])
      // 得到黑白棋子分别的个数
      const [black, white] = board.reduce(([black, white], line) => {
        const [curB, curW] = line.reduce(([b, w], grid) => {
          if (grid === 1)++b;
          if (grid === 2)++w;
          return [b, w];
        }, [0, 0]);

        return [black += curB, white += curW]
      }, [0, 0])

      let result;
      if (black > white) {
        result = 'black wins';
      } else if (black < white) {
        result = 'white wins';
      } else {
        result = "draw";
      }
      alert(`Black: ${black}, white: ${white}. The result is ${result}`);
    }

    function render() {
      // 清空旧的
      container.innerHTML = '';

      for (let y = 0; y < 8; y++) {
        for (let x = 0; x < 8; x++) {
          // 棋盘格
          const grid = document.createElement("div");
          grid.style = "display: inline-block; width: 50px; height: 50px; background-color: darkcyan; border: solid white 1px; vertical-align: bottom;";

          // 绑定点击
          grid.addEventListener("click", () => {
            move(x, y);

            if (checkPass()) {
              // 当前选手本轮无子可走，pass
              curColorValue = 3 - curColorValue;
              console.log('pass')
              if (checkPass()) {
                // 连着 pass 两次，双方都没得走了，gameover
                console.log('game over')
                // judge();
                setTimeout(judge, 100);
              }
            }
            // move(x, y);
            render();
          });

          container.appendChild(grid);
          // 棋子 css 伪元素？
          if (board[y][x] === 1) {
            const disc = document.createElement("div");
            disc.style = "margin: 5px; width: 40px; height: 40px; border-radius: 20px; background-color: black;"
            grid.appendChild(disc)
          }
          if (board[y][x] === 2) {
            const disc = document.createElement("div");
            disc.style = "margin: 5px; width: 40px; height: 40px; border-radius: 20px; background-color: antiquewhite;"
            grid.appendChild(disc)
          }
        };
        // 分行
        container.appendChild(document.createElement("br"));
      };
    }


  </script>
</body>

</html>